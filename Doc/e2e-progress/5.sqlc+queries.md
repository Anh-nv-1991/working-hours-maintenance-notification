1.  Tạo queries trong db/queries
```sql
--1.##db/queries/devices.sql
-- name: CreateDevice :one
INSERT INTO devices (
  serial_number, name, model, manufacturer, year_of_manufacture,
  commission_date, total_working_hour, after_overhaul_working_hour,
  status, last_service_at, location, plan_id, created_at, updated_at
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,NOW(),NOW()
) RETURNING *;

-- name: GetDevice :one
SELECT * FROM devices WHERE id = $1 LIMIT 1;

-- name: ListDevices :many
SELECT * FROM devices
WHERE deleted_at IS NULL
ORDER BY id
LIMIT $1 OFFSET $2;

-- name: UpdateDeviceBasic :one
UPDATE devices SET
  name = $2,
  status = $3,
  location = $4,
  updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: UpdateDevicePlan :one
UPDATE devices SET
  plan_id = $2,
  updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: SoftDeleteDevice :exec
UPDATE devices SET deleted_at = NOW() WHERE id = $1;


--##2.db/queries/plans.sql
-- name: CreatePlan :one
INSERT INTO plans (name, interval_hours, description, created_at, updated_at)
VALUES ($1,$2,$3,NOW(),NOW()) RETURNING *;

-- name: GetPlan :one
SELECT * FROM plans WHERE id = $1 LIMIT 1;

-- name: ListPlans :many
SELECT * FROM plans ORDER BY id LIMIT $1 OFFSET $2;

-- name: UpdatePlan :one
UPDATE plans SET
  name = $2,
  interval_hours = $3,
  description = $4,
  updated_at = NOW()
WHERE id = $1
RETURNING *;

-- name: DeletePlan :exec
DELETE FROM plans WHERE id = $1;


--#3.db/queries/readings.sql
-- name: CreateReading :one
INSERT INTO readings (device_id, at, hours_delta, location, operator_id)
VALUES ($1,$2,$3,$4,$5)
RETURNING *;

-- name: ListReadingsByDevice :many
SELECT * FROM readings
WHERE device_id = $1
ORDER BY at DESC
LIMIT $2 OFFSET $3;

-- name: GetLastReading :one
SELECT * FROM readings
WHERE device_id = $1
ORDER BY at DESC
LIMIT 1;

-- name: DeleteReading :exec
DELETE FROM readings WHERE id = $1;


--#4db/queries/alerts.sql
-- name: CreateAlert :one
INSERT INTO alerts (device_id, type, message)
VALUES ($1,$2,$3)
RETURNING *;

-- name: ListOpenAlertsByDevice :many
SELECT * FROM alerts
WHERE device_id = $1 AND resolved = FALSE
ORDER BY created_at DESC
LIMIT $2 OFFSET $3;

-- name: ResolveAlert :one
UPDATE alerts SET
  resolved = TRUE,
  resolved_at = NOW(),
  resolved_by = $2
WHERE id = $1
RETURNING *;

--#5.db/queries/maintenance_events.sql
-- name: CreateMaintenanceEvent :one
INSERT INTO maintenance_events (device_id, at, interval, notes, performed_by, cost)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id, device_id, at, interval, notes, performed_by, cost, created_at;

-- name: ListMaintenanceByDevice :many
SELECT * FROM maintenance_events
WHERE device_id = $1
ORDER BY at DESC
LIMIT $2 OFFSET $3;

-- name: DeleteMaintenanceEvent :exec
DELETE FROM maintenance_events WHERE id = $1;
```

2.  Tạo bootstrap- db.go
```go
package dbbootstrap

import (
	"context"
	"log"
	"os"
	"time"

	"wh-ma/internal/adapter/outbound/repository/sqlc"

	"github.com/jackc/pgx/v5/pgxpool"
)

// NewDB khởi tạo connection pool tới Postgres và return Queries (sqlc)
func NewDB() (*sqlc.Queries, *pgxpool.Pool) {
	databaseURL := os.Getenv("DATABASE_URL")
	if databaseURL == "" {
		log.Fatal("DATABASE_URL not set")
	}

	cfg, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		log.Fatalf("failed to parse DATABASE_URL: %v", err)
	}

	// optional: tuning pool
	cfg.MaxConns = 10
	cfg.MinConns = 2
	cfg.MaxConnLifetime = time.Hour
	cfg.MaxConnIdleTime = 30 * time.Minute
	cfg.HealthCheckPeriod = 30 * time.Second

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	pool, err := pgxpool.NewWithConfig(ctx, cfg)
	if err != nil {
		log.Fatalf("failed to create pgx pool: %v", err)
	}

	// kiểm tra kết nối
	if err := pool.Ping(ctx); err != nil {
		log.Fatalf("cannot connect to database: %v", err)
	}

	log.Println("✅ Connected to Postgres")

	queries := sqlc.New(pool)
	return queries, pool
}
```
3.  tải pgx driver 
go get github.com/jackc/pgx/v5

4. Tạo các sqlc
  docker compose run --rm sqlc

5. Demo main.go
```go
// cmd/server/main.go
package main

import (
	"log"
	"net/http"
	"wh-ma/internal/adapter/outbound/repository/sqlc"
	"wh-ma/internal/bootstrap"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

func main() {

	// load .env file (nếu có)
	if err := godotenv.Load("configs/.env"); err != nil {
		log.Println("No .env file found")
	}
	// khởi tạo DB
	// trả về sqlc.Queries và pgxpool.Pool
	// nhớ defer pool.Close()
	q, pool := bootstrap.NewDB()
	defer pool.Close()

	// khởi tạo Gin
	r := gin.Default()

	// healthz dùng để kiểm tra DB nhanh
	r.GET("/healthz", func(c *gin.Context) {
		if err := pool.Ping(c); err != nil {
			c.JSON(http.StatusServiceUnavailable, gin.H{"ok": false, "err": err.Error()})
			return
		}
		c.JSON(http.StatusOK, gin.H{"ok": true})
	})

	// demo: GET /devices?limit=10&offset=0
	r.GET("/devices", func(c *gin.Context) {
		limit, offset := int32(10), int32(0)
		if v := c.Query("limit"); v != "" { /* parse to int32 */
		}
		if v := c.Query("offset"); v != "" { /* parse to int32 */
		}

		list, err := q.ListDevices(c, sqlc.ListDevicesParams{Limit: limit, Offset: offset})
		if err != nil {
			c.JSON(500, gin.H{"error": err.Error()})
			return
		}
		c.JSON(200, list)
	})

	// lắng nghe cổng 8080
	log.Println("listening on :8080")
	if err := r.Run(":8080"); err != nil {
		log.Fatal(err)
	}
}

```
6. Cài gin và context go go
  go get github.com/gin-gonic/gin@latest

7. Chạy thử server
  docker run --rm -v ${PWD}:/app -w /app sqlc/sqlc:1.27.0 generate

8. Demo 1 bản ghi vào devices của database để kiểm tra
```sql
INSERT INTO devices (
  serial_number, name, model, manufacturer, year_of_manufacture,
  commission_date, total_working_hour, after_overhaul_working_hour,
  status, last_service_at, location, created_at, updated_at
) VALUES (
  '77000', '02', 'PC-2000-11', 'Komatsu', 2022,
  '2022-05-20', 100, 0,
  'active', NULL, 'Zone A', NOW(), NOW()
);
```
