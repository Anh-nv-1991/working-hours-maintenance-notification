1. repo implement build
```go
package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"

	"wh-ma/internal/adapter/outbound/port"
	dbsqlc "wh-ma/internal/adapter/outbound/repository/sqlc"
	"wh-ma/internal/domain"
)

// Bản PG/sqlc implement ReadingRepository
type ReadingRepositoryPG struct {
	pool *pgxpool.Pool
	q    *dbsqlc.Queries
}

func NewReadingRepository(pool *pgxpool.Pool) *ReadingRepositoryPG {
	return &ReadingRepositoryPG{
		pool: pool,
		q:    dbsqlc.New(pool),
	}
}

// compile-time check
var _ port.ReadingRepository = (*ReadingRepositoryPG)(nil)

// Create -> INSERT readings ... RETURNING ...
func (r *ReadingRepositoryPG) Create(ctx context.Context, in port.CreateReadingInput) (*domain.Reading, error) {
	row, err := r.q.CreateReading(ctx, dbsqlc.CreateReadingParams{
		DeviceID:   int64(in.DeviceID),
		At:         pgtype.Timestamptz{Time: in.At, Valid: true},
		HoursDelta: int32(in.HoursDelta),
		Location:   in.Location,   // *string
		OperatorID: in.OperatorID, // *string
	})
	if err != nil {
		return nil, err
	}
	rd := mapSqlcReadingToDomain(row)
	return &rd, nil
}

// GetLastByDevice -> ORDER BY at DESC LIMIT 1
func (r *ReadingRepositoryPG) GetLastByDevice(ctx context.Context, deviceID domain.DeviceID) (*domain.Reading, error) {
	row, err := r.q.GetLastReading(ctx, int64(deviceID))
	if err != nil {
		return nil, err
	}
	rd := mapSqlcReadingToDomain(row)
	return &rd, nil
}

// ListByDevice -> phân trang theo at DESC
func (r *ReadingRepositoryPG) ListByDevice(ctx context.Context, deviceID domain.DeviceID, limit, offset int32) ([]*domain.Reading, error) {
	rows, err := r.q.ListReadingsByDevice(ctx, dbsqlc.ListReadingsByDeviceParams{
		DeviceID: int64(deviceID),
		Limit:    limit,
		Offset:   offset,
	})
	if err != nil {
		return nil, err
	}
	out := make([]*domain.Reading, 0, len(rows))
	for _, row := range rows {
		rd := mapSqlcReadingToDomain(row)
		out = append(out, &rd)
	}
	return out, nil
}

// Delete -> DELETE FROM readings WHERE id = $1
func (r *ReadingRepositoryPG) Delete(ctx context.Context, id int64) error {
	return r.q.DeleteReading(ctx, id)
}

// ===== mapper =====
func mapSqlcReadingToDomain(x dbsqlc.Reading) domain.Reading {
	var at time.Time
	if x.At.Valid {
		at = x.At.Time
	}
	return domain.Reading{
		ID:         x.ID,
		DeviceID:   domain.DeviceID(x.DeviceID),
		At:         at,
		HoursDelta: int(x.HoursDelta),
		Location:   strOrEmptyPtr(x.Location),
		OperatorID: strOrEmptyPtr(x.OperatorID),
	}
}

// trả về string, nhưng domain đang cần string (không nil).
// Nếu ACE muốn giữ nil, đổi field domain thành *string và map thẳng.
func strOrEmptyPtr(p *string) string {
	if p != nil {
		return *p
	}
	return ""
}
```
2. interface build
```go
package port

import (
	"context"
	"time"

	"wh-ma/internal/domain"
)

// Hợp đồng để Usecase gọi
type ReadingRepository interface {
	Create(ctx context.Context, in CreateReadingInput) (*domain.Reading, error)
	GetLastByDevice(ctx context.Context, deviceID domain.DeviceID) (*domain.Reading, error)
	ListByDevice(ctx context.Context, deviceID domain.DeviceID, limit, offset int32) ([]*domain.Reading, error)
	Delete(ctx context.Context, id int64) error
}

// Payload tạo mới Reading
type CreateReadingInput struct {
	DeviceID   domain.DeviceID
	At         time.Time
	HoursDelta int
	Location   *string
	OperatorID *string
}
