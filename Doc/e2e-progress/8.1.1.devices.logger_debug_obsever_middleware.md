1. suggested flow
```go
RequestID + Logger middleware (1 file, 1 giờ làm là xong).

Bọc devices use-case/handler: log start/done + đo thời gian.

Prometheus metrics cho devices + /metrics.

Readiness DB (đã có) – chỉ đảm bảo phản hồi đúng.

Slow query logging (server-side PG trước, rồi client-side sau).

(Day-2+) OTel tracing Gin + pgx; dashboards & alerts.
```
A. RequestID
    1. cài package 
        go get github.com/gin-contrib/requestid
    2. Thêm middleware chịu trách nhiệm gắn request-id cho các request.
    requestlog.go Middleware sẽ được dùng chung cho toàn hệ thống và được tiêm trong bootstrap.
```go
package middleware

import (
	"context"
	"log/slog"
	"net"
	"os"
	"strings"
	"time"

	"github.com/gin-contrib/requestid"
	"github.com/gin-gonic/gin"
)

type ctxKey string

const LoggerKey ctxKey = "logger"

// NewBaseLogger tạo logger gốc theo LOG_LEVEL (env) và output JSON.
func NewBaseLogger() *slog.Logger {
	level := slog.LevelInfo
	switch strings.ToLower(os.Getenv("LOG_LEVEL")) {
	case "debug":
		level = slog.LevelDebug
	case "warn":
		level = slog.LevelWarn
	case "error":
		level = slog.LevelError
	}
	return slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: level}))
}

// RequestLogMiddleware:
// - đảm bảo có X-Request-ID (tạo nếu client không gửi)
// - đưa logger vào context, đính kèm field cơ bản
// - log access line ở cuối (status, latency, size)
func RequestLogMiddleware(base *slog.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		// đảm bảo đã có request id
		reqID := requestid.Get(c)
		start := time.Now()

		route := c.FullPath()
		if route == "" {
			route = c.Request.URL.Path
		}

		ip := clientIP(c)
		userAgent := c.Request.UserAgent()

		// logger cho request hiện tại
		l := base.With(
			"request_id", reqID,
			"method", c.Request.Method,
			"route", route,
			"ip", ip,
		)

		// đưa logger vào context chuẩn
		ctx := context.WithValue(c.Request.Context(), LoggerKey, l)
		c.Request = c.Request.WithContext(ctx)

		// log start ở mức debug (không ồn khi level >= info)
		l.Debug("request.start", "ua", userAgent)

		// chạy các handler tiếp theo
		c.Next()

		latency := time.Since(start)
		status := c.Writer.Status()
		size := c.Writer.Size()

		// access log: 1 dòng/tác vụ
		l.Info("request.done",
			"status", status,
			"latency_ms", latency.Milliseconds(),
			"size", size,
			"err", strings.Join(c.Errors.Errors(), "; "),
		)
	}
}

// GetLogger rút logger từ context. Nếu thiếu, trả base để không nil.
func GetLogger(ctx context.Context, fallback *slog.Logger) *slog.Logger {
	if v := ctx.Value(LoggerKey); v != nil {
		if l, ok := v.(*slog.Logger); ok {
			return l
		}
	}
	return fallback
}

// clientIP lấy IP thực tế, tôn trọng X-Forwarded-For nếu có reverse proxy.
func clientIP(c *gin.Context) string {
	// Ưu tiên X-Forwarded-For (chuỗi ip, lấy ip đầu)
	if xff := c.GetHeader("X-Forwarded-For"); xff != "" {
		parts := strings.Split(xff, ",")
		return strings.TrimSpace(parts[0])
	}
	// Fallback: RemoteAddr
	host, _, err := net.SplitHostPort(c.Request.RemoteAddr)
	if err != nil {
		return c.ClientIP() // gin đã cố gắng parse giúp
	}
	return host
}
```

    3.  cmd/server/main.go — BẮT BUỘC SỬA
        Tạo baseLogger (JSON, theo LOG_LEVEL) rồi truyền vào BuildRouter(...).
        Dùng baseLogger để log sự kiện khởi động/tắt thay vì log.Printf.
        Hiện file đang gọi BuildRouter(cfg, pool) và log bằng log.*, cần cập nhật theo wiring mới.  
	
	4. Tạo observe để xem thời gian respond của request.
		observe.go
```go
package handler

import (
	"context"
	"log/slog"
	"time"

	"wh-ma/internal/adapter/inbound/http/middleware"

	"github.com/gin-gonic/gin"
)

// toArgs chuyển []slog.Attr -> []any để truyền vào logger.Info(...any)
func toArgs(attrs []slog.Attr) []any {
	out := make([]any, 0, len(attrs))
	for _, a := range attrs {
		out = append(out, a)
	}
	return out
}

// getLogger: lấy logger từ middleware (đúng chữ ký) với fallback base logger
func getLogger(ctx context.Context) *slog.Logger {
	base := slog.Default() // hoặc middleware.NewBaseLogger() nếu ACE đã có
	return middleware.GetLogger(ctx, base)
}

func observe(c *gin.Context, op string) (done func(attrs ...slog.Attr)) {
	logger := getLogger(c.Request.Context())
	start := time.Now()

	logger.Info("start "+op,
		slog.String("method", c.Request.Method),
		slog.String("path", c.FullPath()),
	)

	return func(attrs ...slog.Attr) {
		base := []slog.Attr{
			slog.String("op", op),
			slog.String("method", c.Request.Method),
			slog.String("path", c.FullPath()),
			slog.Duration("took", time.Since(start)),
		}
		all := append(base, attrs...) // []slog.Attr
		logger.Info("done "+op, toArgs(all)...)
	}
}
```

		5.Bọc các phương thức trong handler với done: observe(...)
```go
##Get
func (h *DevicesHandler) Get(c *gin.Context) {
    done := observe(c, "GetDevice")
    status := http.StatusOK
    var errMsg string
    var id domain.DeviceID

    defer func() {
        done(
            slog.Int("status", status),
            slog.String("error", errMsg),
            slog.Int64("device_id", int64(id)),
        )
    }()

    var ok bool
    id, ok = parseDeviceID(c)
    if !ok {
        status = http.StatusBadRequest
        errMsg = "invalid id"
        return // parseDeviceID đã trả JSON 400 rồi
    }

    dev, err := h.svc.Get(c, id)
    if err != nil {
        status = http.StatusNotFound
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }
    c.JSON(status, dev)
}

##List
func (h *DevicesHandler) List(c *gin.Context) {
    done := observe(c, "ListDevices")
    status := http.StatusOK
    var errMsg string
    limit, offset := parsePaging(c, 50, 0)

    defer func() {
        done(
            slog.Int("status", status),
            slog.String("error", errMsg),
            slog.Int("limit", int(limit)),
            slog.Int("offset", int(offset)),
        )
    }()

    devs, err := h.svc.List(c, limit, offset)
    if err != nil {
        status = http.StatusInternalServerError
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }
    c.JSON(status, gin.H{"items": devs, "limit": limit, "offset": offset})
}

##UpdateBasic
func (h *DevicesHandler) UpdateBasic(c *gin.Context) {
    done := observe(c, "UpdateDeviceBasic")
    status := http.StatusOK
    var errMsg string
    var id domain.DeviceID

    defer func() {
        done(
            slog.Int("status", status),
            slog.String("error", errMsg),
            slog.Int64("device_id", int64(id)),
        )
    }()

    var ok bool
    id, ok = parseDeviceID(c)
    if !ok {
        status = http.StatusBadRequest
        errMsg = "invalid id"
        return
    }

    var in request.UpdateBasic
    if err := c.ShouldBindJSON(&in); err != nil {
        status = http.StatusBadRequest
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }

    cmd := dto.UpdateDeviceBasicCmd{
        ID:       id,
        Name:     in.Name,
        Status:   domain.DeviceStatus(in.Status),
        Location: in.Location,
    }
    dev, err := h.svc.UpdateBasic(c, cmd)
    if err != nil {
        status = http.StatusBadRequest
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }
    c.JSON(status, dev)
}

##UpdatePlan
func (h *DevicesHandler) UpdatePlan(c *gin.Context) {
    done := observe(c, "UpdateDevicePlan")
    status := http.StatusOK
    var errMsg string
    var id domain.DeviceID
    var planID *domain.PlanID

    defer func() {
        attrs := []slog.Attr{
            slog.Int("status", status),
            slog.String("error", errMsg),
            slog.Int64("device_id", int64(id)),
        }
        if planID != nil {
            attrs = append(attrs, slog.Int64("plan_id", int64(*planID)))
        }
        done(attrs...)
    }()

    var ok bool
    id, ok = parseDeviceID(c)
    if !ok {
        status = http.StatusBadRequest
        errMsg = "invalid id"
        return
    }

    var in request.UpdatePlan
    if err := c.ShouldBindJSON(&in); err != nil {
        status = http.StatusBadRequest
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }

    if in.PlanID != nil {
        v := domain.PlanID(*in.PlanID)
        planID = &v
    }

    cmd := dto.UpdateDevicePlanCmd{ID: id, PlanID: planID}
    dev, err := h.svc.UpdatePlan(c, cmd)
    if err != nil {
        status = http.StatusBadRequest
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }
    c.JSON(status, dev)
}

##SoftDelete
func (h *DevicesHandler) SoftDelete(c *gin.Context) {
    done := observe(c, "SoftDeleteDevice")
    status := http.StatusNoContent
    var errMsg string
    var id domain.DeviceID

    defer func() {
        done(
            slog.Int("status", status),
            slog.String("error", errMsg),
            slog.Int64("device_id", int64(id)),
        )
    }()

    var ok bool
    id, ok = parseDeviceID(c)
    if !ok {
        status = http.StatusBadRequest
        errMsg = "invalid id"
        return
    }

    if err := h.svc.SoftDelete(c, id); err != nil {
        status = http.StatusBadRequest
        errMsg = err.Error()
        c.JSON(status, gin.H{"error": errMsg})
        return
    }
    c.Status(status) // 204
}
```
		6. Tạo dockerfile trong build/ build lại docker compose
```go
# ---- build stage ----
FROM golang:1.25 AS builder
WORKDIR /src
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
    go build -trimpath -ldflags="-s -w" -o /out/server ./cmd/server

# ---- run stage (distroless, non-root) ----
FROM gcr.io/distroless/static:nonroot
WORKDIR /app
USER nonroot:nonroot
ENV PORT=8080
COPY --from=builder /out/server /app/server
EXPOSE 8080
ENTRYPOINT ["/app/server"]
```

