1. Nhiệm vụ của Prometheus/metrics dùng để tổng hợp số lượng request, nhóm thành đồ thị các request có thời gian xử lí dài.
2. cài go package 
go get github.com/prometheus/client_golang@v1
3. Triển khai
```go
Bước 1 — Gói metrics (định nghĩa & đăng ký)

Tạo internal/observability/metrics/metrics.go:

package metrics

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

// HTTP
var (
	HTTPRequestsTotal = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Total number of HTTP requests.",
		},
		[]string{"path", "method", "status"},
	)

	HTTPRequestDuration = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "Latency distributions of HTTP requests.",
			Buckets: prometheus.DefBuckets, // 10ms..10s
		},
		[]string{"path", "method"},
	)
)

// Domain-specific: devices
var (
	DeviceCreatedTotal = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "devices_created_total",
			Help: "Number of devices created.",
		},
	)

	DeviceListTotal = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "devices_list_total",
			Help: "Number of device list operations.",
		},
	)
)

Bước 2 — Middleware đo thời gian & đếm request

Tạo internal/adapter/inbound/http/middleware/metrics.go:

package metrics

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

// HTTP
var (
	HTTPRequestsTotal = promauto.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Total number of HTTP requests.",
		},
		[]string{"path", "method", "status"},
	)

	HTTPRequestDuration = promauto.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "Latency distributions of HTTP requests.",
			Buckets: prometheus.DefBuckets, // 10ms..10s
		},
		[]string{"path", "method"},
	)
)

// Domain-specific: devices
var (
	DeviceCreatedTotal = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "devices_created_total",
			Help: "Number of devices created.",
		},
	)

	DeviceListTotal = promauto.NewCounter(
		prometheus.CounterOpts{
			Name: "devices_list_total",
			Help: "Number of device list operations.",
		},
	)
)


Bước 3 — Expose /metrics

Trong router, add handler Prometheus chuẩn (không cần auth cho nội bộ dev; lên prod thì đặt network policy/nginx):

// internal/adapter/inbound/http/router/router.go
package router

import (
	"github.com/gin-gonic/gin"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"wh-ma/internal/adapter/inbound/http/handler"
	"wh-ma/internal/adapter/inbound/http/middleware"
)

func New() *gin.Engine {
	r := gin.New()
	r.Use(gin.Recovery())
	r.Use(middleware.RequestID())    // nếu đã có
	r.Use(middleware.Logger())       // nếu đã có
	r.Use(middleware.PrometheusHTTP())

	// Health
	r.GET("/healthz", handler.Healthz)
	r.GET("/readiness", handler.Readiness)

	// Devices (ví dụ)
	r.GET("/devices", handler.ListDevices)
	r.POST("/devices", handler.CreateDevice)

	// Metrics
	r.GET("/metrics", gin.WrapH(promhttp.Handler()))

	return r
}

Bước 4 — Gắn metrics vào handler domain (tùy chọn nhưng nên làm)

Ví dụ trong CreateDevice và ListDevices tăng counter domain:

package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
	"wh-ma/internal/observability/metrics"
)

func CreateDevice(c *gin.Context) {
	// ... validate + usecase.CreateDevice(...)
	metrics.DeviceCreatedTotal.Inc()
	c.JSON(http.StatusCreated, gin.H{"ok": true})
}

func ListDevices(c *gin.Context) {
	// ... query devices ...
	metrics.DeviceListTotal.Inc()
	c.JSON(http.StatusOK, gin.H{"data": []any{}})
}

Bước 5 — Docker (không đổi cổng)


Bước 6 — Kiểm thử nhanh

Chạy:

docker compose up -d --build
curl http://localhost:8080/healthz
curl http://localhost:8080/devices
curl http://localhost:8080/metrics


Trong /metrics sẽ thấy các dòng như:

http_requests_total{method="GET",path="/devices",status="200"} 1
http_request_duration_seconds_bucket{method="GET",path="/devices",le="0.005"} ...
devices_created_total 3

Bước 7 — (Tùy chọn) Thêm Prometheus vào docker-compose

Nếu ACE muốn tự scrape local, thêm service Prometheus + file prometheus.yml.

prometheus.yml (đặt ở ./ops/prometheus/prometheus.yml):

global:
  scrape_interval: 15s

scrape_configs:
  - job_name: "wh-ma-api"
    metrics_path: /metrics
    static_configs:
      - targets: ["api:8080"]  # container-to-container


docker-compose (thêm service):

services:
  prometheus:
    image: prom/prometheus:v2.54.1
    volumes:
      - ./ops/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    ports:
      - "9090:9090"
    depends_on:
      - api

///////==============Bước 6- sửa lại devices bootstrap chỉ còn nhiệm vụ tạo instances và wiring
package bootstrap

import (
	"context"
	"log"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"

	"wh-ma/internal/adapter/inbound/http/handler"
	"wh-ma/internal/adapter/inbound/http/router"
	outrepo "wh-ma/internal/adapter/outbound/repository"
	"wh-ma/internal/usecase"
)

// ===== Config =====

type AppConfig struct {
	AppEnv      string
	Port        string
	DatabaseURL string
	AllowOrigin []string
	LogLevel    string
}

func LoadConfig() AppConfig {
	LoadEnvFirst()
	cfg := AppConfig{
		AppEnv:      getenv("APP_ENV", "development"),
		Port:        getenv("PORT", "8080"),
		DatabaseURL: getenv("DATABASE_URL", ""),
		LogLevel:    getenv("LOG_LEVEL", "info"),
	}
	origins := getenv("CORS_ORIGINS", "*")
	if origins == "" {
		cfg.AllowOrigin = []string{"*"}
	} else {
		cfg.AllowOrigin = strings.Split(origins, ",")
	}
	return cfg
}

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

// ===== DB Pool =====

func NewPGXPool(ctx context.Context, dbURL string) (*pgxpool.Pool, error) {
	cfg, err := pgxpool.ParseConfig(dbURL)
	if err != nil {
		return nil, err
	}
	pool, err := pgxpool.NewWithConfig(ctx, cfg)
	if err != nil {
		return nil, err
	}
	ctxPing, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	if err := pool.Ping(ctxPing); err != nil {
		pool.Close()
		return nil, err
	}
	return pool, nil
}

// ===== HTTP wiring (router layer định nghĩa endpoints) =====

func BuildRouter(cfg AppConfig, pool *pgxpool.Pool, baseLogger *slog.Logger) *gin.Engine {
	// 1) Repos
	devRepo := outrepo.NewDeviceRepository(pool)
	planRepo := outrepo.NewPlanRepository(pool)
	alertRepo := outrepo.NewAlertRepository(pool)

	// 2) Usecases
	devUC := usecase.NewDevicesUsecase(devRepo, planRepo, alertRepo)

	// 3) Handlers
	devH := handler.NewDevicesHandler(devUC)

	// 4) Router gốc (đã gắn Recovery, RequestID, Logger, CORS, Prometheus, healthz/readiness, /metrics)
	r := router.New(pool, baseLogger, router.Options{
		AppEnv:      cfg.AppEnv,
		AllowOrigin: cfg.AllowOrigin,
	})

	// 5) Mount modules vào /api
	api := r.Group("/api")
	router.MountDevices(api, devH)

	return r
}

// RunHTTP: chạy server với graceful shutdown
func RunHTTP(r *gin.Engine, port string) error {
	srv := &http.Server{
		Addr:              ":" + port,
		Handler:           r,
		ReadHeaderTimeout: 10 * time.Second,
	}

	// Start server
	errCh := make(chan error, 1)
	go func() {
		log.Printf("HTTP listening on :%s", port)
		errCh <- srv.ListenAndServe()
	}()

	// Wait signal
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

	select {
	case sig := <-stop:
		log.Printf("shutdown signal: %s", sig)
	case err := <-errCh:
		if err != nil && err != http.ErrServerClosed {
			return err
		}
	}

	// Graceful shutdown
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return srv.Shutdown(ctx)
}

//////================ Bước 7. Sửa lại router với nhiệm vụ chuyên toạn router layout
package router

import (
	"log/slog"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-contrib/requestid"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"wh-ma/internal/adapter/inbound/http/health"
	"wh-ma/internal/adapter/inbound/http/middleware"
)

// Options cho Router.New để cấu hình CORS/mode
type Options struct {
	AppEnv      string   // "production" => gin.ReleaseMode
	AllowOrigin []string // []{"*"} => AllowAllOrigins
}

// New tạo *gin.Engine với middleware & infra endpoints
// - Recovery, RequestID, Logger
// - CORS
// - Prometheus middleware + /metrics
// - /healthz, /readiness
//
// Domain endpoints (devices, plans, alerts, readings) sẽ được mount từ bootstrap
// qua các hàm router.Mount* vào group /api.
func New(p *pgxpool.Pool, baseLogger *slog.Logger, opt Options) *gin.Engine {
	if opt.AppEnv == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	r := gin.New()

	// Middlewares nền tảng
	r.Use(gin.Recovery())
	r.Use(requestid.New())
	r.Use(middleware.RequestLogMiddleware(baseLogger)) // logger có request-id
	r.Use(middleware.PrometheusHTTP())                 // đo count/latency/status cho mọi request

	// CORS
	c := cors.DefaultConfig()
	if len(opt.AllowOrigin) == 1 && opt.AllowOrigin[0] == "*" {
		c.AllowAllOrigins = true
	} else if len(opt.AllowOrigin) > 0 {
		c.AllowOrigins = opt.AllowOrigin
	} else {
		c.AllowAllOrigins = true
	}
	c.AllowHeaders = []string{"Authorization", "Content-Type"}
	c.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	r.Use(cors.New(c))

	// Infra endpoints
	h := health.NewHandler(p)
	r.GET("/healthz", h.Liveness)                    // liveness: không ping DB
	r.GET("/readiness", h.Readiness)                 // readiness: ping DB ngắn
	r.GET("/metrics", gin.WrapH(promhttp.Handler())) // Prometheus scrape

	// Ping root (optional)
	r.GET("/", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{"ok": true}) })

	// Domain routes sẽ được mount ở bootstrap:
	//   api := r.Group("/api")
	//   router.MountDevices(api, devicesHandler)
	//   router.MountPlans(api, plansHandler)
	//   router.MountAlerts(api, alertsHandler)
	//   router.MountReadings(api, readingsHandler)

	return r
}
 ///=============== CLI kiểm tra metrics hoạt động và tổng hợp kết quả
$txt = irm http://localhost:8080/metrics
>> $txt -split "`n" | ? { $_ -match '^(?!#)\s*devices_created_total(\{| )' }
>> $txt -split "`n" | ? { $_ -match '^(?!#)\s*devices_list_total(\{| )' }
devices_created_total 1
```

