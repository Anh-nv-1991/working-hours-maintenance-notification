1. DTO cho devices
```go
package dto

import (
	"time"
	"wh-ma/internal/domain"
)

type CreateDeviceCmd struct {
	SerialNumber   string
	Name           string
	Model          string
	Manufacturer   string
	Year           int
	CommissionDate *time.Time
	Status         domain.DeviceStatus
	Location       *string
	PlanID         *domain.PlanID
}

type UpdateDeviceBasicCmd struct {
	ID       domain.DeviceID
	Name     string
	Status   domain.DeviceStatus
	Location *string
}

type UpdateDevicePlanCmd struct {
	ID     domain.DeviceID
	PlanID *domain.PlanID // nil = bỏ kế hoạch
}
```

2. request cho devices
```go
package request

import "time"

// POST /devices
type CreateDevice struct {
	SerialNumber   string     `json:"serial_number" binding:"required"`
	Name           string     `json:"name" binding:"required"`
	Model          string     `json:"model"`
	Manufacturer   string     `json:"manufacturer"`
	Year           int        `json:"year"`
	CommissionDate *time.Time `json:"commission_date"` // RFC3339
	Status         string     `json:"status"`          // optional; default "active"
	Location       *string    `json:"location"`
	PlanID         *int64     `json:"plan_id"`
}

// PATCH /devices/:id
type UpdateBasic struct {
	Name     string  `json:"name" binding:"required"`
	Status   string  `json:"status" binding:"required"`
	Location *string `json:"location"` // optional
}

// PATCH /devices/:id/plan  (nil -> bỏ plan)
type UpdatePlan struct {
	PlanID *int64 `json:"plan_id"`
}
```

3. Handler cho devices
```go
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"

	"wh-ma/internal/adapter/inbound/http/request"
	inport "wh-ma/internal/adapter/inbound/port"
	"wh-ma/internal/domain"
	"wh-ma/internal/usecase/dto"
)

type DevicesHandler struct {
	svc inport.DevicesInbound
}

func NewDevicesHandler(svc inport.DevicesInbound) *DevicesHandler {
	return &DevicesHandler{svc: svc}
}

// POST /devices
func (h *DevicesHandler) Create(c *gin.Context) {
	var in request.CreateDevice
	if err := c.ShouldBindJSON(&in); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var planID *domain.PlanID
	if in.PlanID != nil {
		v := domain.PlanID(*in.PlanID)
		planID = &v
	}
	cmd := dto.CreateDeviceCmd{
		SerialNumber:   in.SerialNumber,
		Name:           in.Name,
		Model:          in.Model,
		Manufacturer:   in.Manufacturer,
		Year:           in.Year,
		CommissionDate: in.CommissionDate,
		Status:         domain.DeviceStatus(in.Status),
		Location:       in.Location,
		PlanID:         planID,
	}
	dev, err := h.svc.Create(c, cmd)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusCreated, dev)
}

// GET /devices/:id
func (h *DevicesHandler) Get(c *gin.Context) {
	id, ok := parseDeviceID(c)
	if !ok {
		return
	}
	dev, err := h.svc.Get(c, id)
	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, dev)
}

// GET /devices
func (h *DevicesHandler) List(c *gin.Context) {
	limit, offset := parsePaging(c, 50, 0)
	devs, err := h.svc.List(c, limit, offset)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"items": devs, "limit": limit, "offset": offset})
}

// PATCH /devices/:id
func (h *DevicesHandler) UpdateBasic(c *gin.Context) {
	id, ok := parseDeviceID(c)
	if !ok {
		return
	}
	var in request.UpdateBasic
	if err := c.ShouldBindJSON(&in); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	cmd := dto.UpdateDeviceBasicCmd{
		ID:       id,
		Name:     in.Name,
		Status:   domain.DeviceStatus(in.Status),
		Location: in.Location,
	}
	dev, err := h.svc.UpdateBasic(c, cmd)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, dev)
}

// PATCH /devices/:id/plan
func (h *DevicesHandler) UpdatePlan(c *gin.Context) {
	id, ok := parseDeviceID(c)
	if !ok {
		return
	}
	var in request.UpdatePlan
	if err := c.ShouldBindJSON(&in); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	var planID *domain.PlanID
	if in.PlanID != nil {
		v := domain.PlanID(*in.PlanID)
		planID = &v
	}
	cmd := dto.UpdateDevicePlanCmd{ID: id, PlanID: planID}
	dev, err := h.svc.UpdatePlan(c, cmd)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, dev)
}

// DELETE /devices/:id (soft delete)
func (h *DevicesHandler) SoftDelete(c *gin.Context) {
	id, ok := parseDeviceID(c)
	if !ok {
		return
	}
	if err := h.svc.SoftDelete(c, id); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.Status(http.StatusNoContent)
}

// ===== helpers =====
func parseDeviceID(c *gin.Context) (domain.DeviceID, bool) {
	var uri struct {
		ID int64 `uri:"id" binding:"required,min=1"`
	}
	if err := c.ShouldBindUri(&uri); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
		return 0, false
	}
	return domain.DeviceID(uri.ID), true
}
func parsePaging(c *gin.Context, defLimit, defOffset int32) (int32, int32) {
	type q struct {
		Limit, Offset *int32 `form:"limit,offset"`
	}
	var qq struct {
		Limit  *int32 `form:"limit"`
		Offset *int32 `form:"offset"`
	}
	_ = c.ShouldBindQuery(&qq)
	limit, offset := defLimit, defOffset
	if qq.Limit != nil {
		limit = *qq.Limit
	}
	if qq.Offset != nil {
		offset = *qq.Offset
	}
	return limit, offset
}
```
4. inboundport devices
```go
package port

import (
	"context"
	"wh-ma/internal/domain"
	"wh-ma/internal/usecase/dto"
)

type DevicesInbound interface {
	// 1) Create
	Create(ctx context.Context, in dto.CreateDeviceCmd) (*domain.Device, error)

	// 5) Get/List
	Get(ctx context.Context, id domain.DeviceID) (*domain.Device, error)
	List(ctx context.Context, limit, offset int32) ([]*domain.Device, error)

	// 2) UpdateBasic
	UpdateBasic(ctx context.Context, in dto.UpdateDeviceBasicCmd) (*domain.Device, error)

	// 3) UpdatePlan
	UpdatePlan(ctx context.Context, in dto.UpdateDevicePlanCmd) (*domain.Device, error)

	// 4) SoftDelete
	SoftDelete(ctx context.Context, id domain.DeviceID) error
}
```

4. devices router
```go
package router

import (
	"wh-ma/internal/adapter/inbound/http/handler"

	"github.com/gin-gonic/gin"
)

func MountDevices(rg *gin.RouterGroup, h *handler.DevicesHandler) {
	g := rg.Group("/devices")
	g.POST("", h.Create)
	g.GET("", h.List)
	g.GET("/:id", h.Get)
	g.PATCH("/:id", h.UpdateBasic)
	g.PATCH("/:id/plan", h.UpdatePlan)
	g.DELETE("/:id", h.SoftDelete)
}
```

5. devices bootstrap
```go
package bootstrap

import (
	"context"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"

	"wh-ma/internal/adapter/inbound/http/handler"
	health "wh-ma/internal/adapter/inbound/http/health"
	"wh-ma/internal/adapter/inbound/http/router"
	outrepo "wh-ma/internal/adapter/outbound/repository"
	"wh-ma/internal/usecase"
)

type AppConfig struct {
	AppEnv      string
	Port        string
	DatabaseURL string
	AllowOrigin []string
}

// LoadConfig: đọc .env qua Compose; không dùng thư viện ngoài để giữ gọn
func LoadConfig() AppConfig {
	LoadEnvFirst()
	cfg := AppConfig{
		AppEnv:      getenv("APP_ENV", "development"),
		Port:        getenv("PORT", "8080"),
		DatabaseURL: getenv("DATABASE_URL", ""),
	}
	origins := getenv("CORS_ORIGINS", "*")
	if origins == "" {
		cfg.AllowOrigin = []string{"*"}
	} else {
		cfg.AllowOrigin = strings.Split(origins, ",")
	}
	return cfg
}

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}

// NewPGXPool: khởi tạo pool và Ping để chắc chắn DB sống
func NewPGXPool(ctx context.Context, dbURL string) (*pgxpool.Pool, error) {
	cfg, err := pgxpool.ParseConfig(dbURL)
	if err != nil {
		return nil, err
	}
	pool, err := pgxpool.NewWithConfig(ctx, cfg)
	if err != nil {
		return nil, err
	}
	ctxPing, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()
	if err := pool.Ping(ctxPing); err != nil {
		pool.Close()
		return nil, err
	}
	return pool, nil
}

// BuildRouter: tạo Gin router, middleware, health, mount modules
func BuildRouter(cfg AppConfig, pool *pgxpool.Pool) *gin.Engine {
	if cfg.AppEnv == "production" {
		gin.SetMode(gin.ReleaseMode)
	}
	r := gin.New()
	r.Use(gin.Logger(), gin.Recovery())

	// CORS
	c := cors.DefaultConfig()
	if len(cfg.AllowOrigin) == 1 && cfg.AllowOrigin[0] == "*" {
		c.AllowAllOrigins = true
	} else {
		c.AllowOrigins = cfg.AllowOrigin
	}
	c.AllowHeaders = []string{"Authorization", "Content-Type"}
	c.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	r.Use(cors.New(c))

	// Health/Readiness
	hh := health.NewHandler(pool)
	r.GET("/healthz", hh.Liveness)    // liveness: không ping DB, trả uptime & timestamp
	r.GET("/readiness", hh.Readiness) // readiness: ping DB với timeout ngắn

	// Outbound repos (PG/sqlc)
	devRepo := outrepo.NewDeviceRepository(pool)
	planRepo := outrepo.NewPlanRepository(pool)
	alertRepo := outrepo.NewAlertRepository(pool)
	// (sẵn sàng cho phần khác) readRepo := outrepo.NewReadingRepository(pool)
	// (sẵn sàng cho phần khác) mntRepo  := outrepo.NewMaintenanceRepository(pool)

	// Usecases (inbound implementations)
	devUC := usecase.NewDevicesUsecase(devRepo, planRepo, alertRepo)

	// Handlers
	devH := handler.NewDevicesHandler(devUC)

	// Router groups
	api := r.Group("/api")
	router.MountDevices(api, devH)

	// Optional: versioning
	// v1 := r.Group("/api/v1")
	// router.MountDevices(v1, devH)

	return r
}

// RunHTTP: chạy server kèm graceful shutdown
func RunHTTP(r *gin.Engine, port string) error {
	srv := &http.Server{
		Addr:              ":" + port,
		Handler:           r,
		ReadHeaderTimeout: 10 * time.Second,
	}
	log.Printf("HTTP listening on :%s", port)
	return srv.ListenAndServe()
}

```

