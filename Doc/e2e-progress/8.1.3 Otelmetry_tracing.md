=== 1. Cập nhật lại .env chạy trên môi trường docker
```docker
APP_ENV=docker
PORT=8080
LOG_LEVEL=debug

# Postgres (TRONG compose: host là "db")
DB_HOST=db
DB_PORT=5432
DB_NAME=main-1
DB_USER=admin
DB_PASSWORD=Vietanh4791

# DSN dùng host "db" (không dùng localhost khi chạy trong container)
DATABASE_URL=postgres://admin:Vietanh4791@db:5432/main-1?sslmode=disable

# Pool
DB_MAX_OPEN_CONNS=25
DB_MAX_IDLE_CONNS=5
DB_CONN_MAX_LIFETIME=300s

# OpenTelemetry (giữ nguyên vì chạy Collector trong compose)
OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger:4318
OTEL_TRACES_SAMPLER=parentbased_traceidratio
OTEL_TRACES_SAMPLER_ARG=1.0
# Đặt service.name để dễ tìm trên Jaeger
OTEL_RESOURCE_ATTRIBUTES=service.name=wh-ma-api,deployment.environment=docker

# ===== OPTIONAL =====
# REDIS (optional)
REDIS_URL=redis://:redis123@localhost:6379/0

# UPLOAD (dùng bytes)
UPLOAD_MAX_SIZE_BYTES=10485760

# JWT (đổi khi lên staging/prod)
JWT_SECRET=change-me-in-prod
JWT_EXPIRE_HOURS=24

```

=== 2.Chỉnh sửa lại docker-compose.yaml
```yaml
services:
  api:
    build:
      context: .
      dockerfile: ./build/Dockerfile
    env_file:
      - ./configs/.env  # ⬅ chọn file env theo biến
    depends_on:
      db:
        condition: service_healthy
      otel-collector:
        condition: service_healthy
    ports:
      - "8080:8080"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:8080/healthz || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5

  otel-collector:
    image: otel/opentelemetry-collector:0.118.0
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ${OTEL_CONFIG_FILE:-./configs/otel-collector.dev.yaml}:/etc/otel-collector-config.yaml:ro  # ⬅ chọn config theo biến
    ports:
      - "4318:4318"
      - "4317:4317"
      - "13133:13133"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:13133/ || exit 1"]
      interval: 10s
      timeout: 3s
      retries: 5

  jaeger:
    image: jaegertracing/all-in-one:1.60
    environment:
      - COLLECTOR_OTLP_ENABLED=true
    ports:
      - "16686:16686"
    restart: unless-stopped

  db:
    image: postgres:16
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: Vietanh4791
      POSTGRES_DB: main-1
    volumes:
      - dbdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U admin -d main-1"]
      interval: 10s
      timeout: 5s
      retries: 5

  migrate:
    image: migrate/migrate:4
    depends_on:
      db:
        condition: service_healthy
    env_file:
      - ./configs/.env
    volumes:
      - ./db/migrations:/migrations:ro
    entrypoint: ["sh","-c","migrate -path=/migrations -database $${DATABASE_URL} up"]

volumes:
  dbdata: {}

```

=== 3. Bổ sung otel-collector-config.yaml
```yaml
receivers:
  otlp:
    protocols:
      http:
        endpoint: 0.0.0.0:4318
      grpc:
        endpoint: 0.0.0.0:4317

processors:
  batch: {}

exporters:
  # Gửi trace sang Jaeger all-in-one qua OTLP/HTTP (4318)
  otlphttp:
    endpoint: http://jaeger:4318
  # (tuỳ chọn) In trace ra log collector để debug
  debug:
    verbosity: basic

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [otlphttp, debug]

```

=== 4. CLI cheatsheet
```shell
3) Cheat sheet CLI (PowerShell)
3.1 Build/Up/Restart
# Build & chạy toàn stack
docker compose up -d --build db otel-collector jaeger api

# Chỉ rebuild API (khi sửa code Go)
docker compose up -d --build api
# hoặc "sạch hẳn":
# docker compose build --no-cache --pull api
# docker compose up -d api

# Restart collector sau khi đổi collector-config
docker compose restart otel-collector

3.2 Migrations
# Áp migrations
docker compose run --rm migrate

# Xem version hiện tại
docker compose run --rm migrate sh -c "migrate -path=/migrations -database $${DATABASE_URL} version"

# Rollback 1 bước
docker compose run --rm migrate sh -c "migrate -path=/migrations -database $${DATABASE_URL} down 1"

3.3 Kiểm tra & Logs
docker compose ps
docker compose logs -f api
docker compose logs -n 100 otel-collector
docker compose logs -n 100 db

3.4 Test nhanh API & OTel
# health/readiness
iwr http://localhost:8080/healthz
iwr http://localhost:8080/readiness -SkipHttpErrorCheck

# Lấy Trace-Id (nếu đã thêm header)
( iwr http://localhost:8080/healthz -SkipHttpErrorCheck ).Headers["Trace-Id"]

# Mở Jaeger UI
start http://localhost:16686

3.5 Dọn dẹp
# Hạ stack + xóa volumes của project (mất dữ liệu DB)
docker compose down -v --remove-orphans --rmi local

# Xóa volumes/images không dùng (an toàn)
docker volume prune -f
docker image prune -f

# Dọn mạnh tay (cẩn trọng: xóa mọi thứ không dùng, cả volumes)
docker system prune -a --volumes -f
```

=== 4. Tạo boostrap otel.go
```go
package bootstrap

import (
	"context"
	"log"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
)

// Tracing giữ hàm Shutdown để gọi defer lúc thoát app
type Tracing struct{ Shutdown func(context.Context) error }

// InitTracing đọc endpoint/sampler từ ENV chuẩn OTel, gắn global TracerProvider
func InitTracing(ctx context.Context, serviceName string) *Tracing {
	// Exporter OTLP/HTTP -> Collector (OTEL_EXPORTER_OTLP_ENDPOINT)
	exp, err := otlptracehttp.New(ctx)
	if err != nil {
		log.Fatalf("otlp exporter: %v", err)
	}

	res, err := resource.New(ctx,
		resource.WithFromEnv(),        // đọc OTEL_RESOURCE_ATTRIBUTES
		resource.WithTelemetrySDK(),
		resource.WithAttributes(       // ghi đè service.name nếu cần
			semconv.ServiceName(serviceName),
		),
	)
	if err != nil {
		log.Fatalf("resource init: %v", err)
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exp),
		sdktrace.WithResource(res),
		// sampler/ratio sẽ tự đọc từ ENV: OTEL_TRACES_SAMPLER(_ARG)
	)
	otel.SetTracerProvider(tp)

	return &Tracing{Shutdown: tp.Shutdown}
}
```

=== 5. Khởi tạo otel_tracing.go
```go
package middleware

import (
	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

func OTelMiddleware(serviceName string) gin.HandlerFunc {
	tracer := otel.Tracer(serviceName)

	return func(c *gin.Context) {
		// tên tạm trước khi Gin match route
		route := c.FullPath()
		if route == "" {
			route = c.Request.URL.Path
		}

		ctx, span := tracer.Start(c.Request.Context(), route,
			trace.WithAttributes(
				attribute.String("http.method", c.Request.Method),
				attribute.String("http.route", route),
				attribute.String("http.target", c.Request.URL.RequestURI()),
			),
		)

		// >>> đặt Trace-Id vào response càng sớm càng tốt
		if tid := span.SpanContext().TraceID().String(); tid != "00000000000000000000000000000000" {
			c.Writer.Header().Set("Trace-Id", tid)
		}

		c.Request = c.Request.WithContext(ctx)
		c.Next()

		// sau khi match xong route, cập nhật lại tên/thuộc tính cho chuẩn
		if rp := c.FullPath(); rp != "" && rp != route {
			span.SetName(rp)
			span.SetAttributes(attribute.String("http.route", rp))
		}

		span.SetAttributes(attribute.Int("http.status_code", c.Writer.Status()))
		if len(c.Errors) > 0 || c.Writer.Status() >= 500 {
			span.SetStatus(codes.Error, c.Errors.String())
		} else {
			span.SetStatus(codes.Ok, "OK")
		}
		span.End()
	}
}

```
 ==== 6. Cập nhật lại routerlayer.go
 ```go
 package router

import (
	"log/slog"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-contrib/requestid"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/prometheus/client_golang/prometheus/promhttp"

	"wh-ma/internal/adapter/inbound/http/health"
	"wh-ma/internal/adapter/inbound/http/middleware"
)

// Options cho Router.New để cấu hình CORS/mode
type Options struct {
	AppEnv      string   // "production" => gin.ReleaseMode
	AllowOrigin []string // []{"*"} => AllowAllOrigins
}

// New tạo *gin.Engine với middleware & infra endpoints
// - Recovery, RequestID, Logger
// - CORS
// - Prometheus middleware + /metrics
// - /healthz, /readiness
//
// Domain endpoints (devices, plans, alerts, readings) sẽ được mount từ bootstrap
// qua các hàm router.Mount* vào group /api.
func New(p *pgxpool.Pool, baseLogger *slog.Logger, opt Options) *gin.Engine {
	if opt.AppEnv == "production" {
		gin.SetMode(gin.ReleaseMode)
	}

	r := gin.New()

	// Middlewares nền tảng
	r.Use(gin.Recovery())
	r.Use(requestid.New())
	r.Use(middleware.OTelMiddleware("wh-ma-api"))
	r.Use(middleware.RequestLogMiddleware(baseLogger)) // logger có request-id
	r.Use(middleware.PrometheusHTTP())                 // đo count/latency/status cho mọi request

	// CORS
	c := cors.DefaultConfig()
	if len(opt.AllowOrigin) == 1 && opt.AllowOrigin[0] == "*" {
		c.AllowAllOrigins = true
	} else if len(opt.AllowOrigin) > 0 {
		c.AllowOrigins = opt.AllowOrigin
	} else {
		c.AllowAllOrigins = true
	}
	c.AllowHeaders = []string{"Authorization", "Content-Type"}
	c.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"}
	r.Use(cors.New(c))

	// Infra endpoints
	h := health.NewHandler(p)
	r.GET("/healthz", h.Liveness)                    // liveness: không ping DB
	r.GET("/readiness", h.Readiness)                 // readiness: ping DB ngắn
	r.GET("/metrics", gin.WrapH(promhttp.Handler())) // Prometheus scrape

	// Ping root (optional)
	r.GET("/", func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{"ok": true}) })

	// Domain routes sẽ được mount ở bootstrap:
	//   api := r.Group("/api")
	//   router.MountDevices(api, devicesHandler)
	//   router.MountPlans(api, plansHandler)
	//   router.MountAlerts(api, alertsHandler)
	//   router.MountReadings(api, readingsHandler)

	return r
}
```

=== 7. Cập nhật observe.go
```go
package handler

import (
	"context"
	"log/slog"
	"time"

	"github.com/gin-gonic/gin"
	"wh-ma/internal/adapter/inbound/http/middleware"
)

// toArgs: []slog.Attr -> []any
func toArgs(attrs []slog.Attr) []any {
	out := make([]any, 0, len(attrs))
	for _, a := range attrs {
		out = append(out, a)
	}
	return out
}

func ctxLogger(ctx context.Context) *slog.Logger {
	return middleware.CtxLogger(ctx, slog.Default())
}

// observe bọc 1 operation trong start/done log
func observe(c *gin.Context, op string) (done func(attrs ...slog.Attr)) {
	l := ctxLogger(c.Request.Context())
	start := time.Now()

	route := c.FullPath()
	if route == "" {
		route = c.Request.URL.Path
	}

	l.Info("start "+op,
		slog.String("method", c.Request.Method),
		slog.String("path", route),
	)

	return func(attrs ...slog.Attr) {
		base := []slog.Attr{
			slog.String("op", op),
			slog.String("method", c.Request.Method),
			slog.String("path", route),
			slog.Duration("took", time.Since(start)),
		}
		l.Info("done "+op, toArgs(append(base, attrs...))...)
	}
}
``` 

=== 8. Cập nhật main.go
```go 
// 3) Init OpenTelemetry (CẤY Ở ĐÂY)
	// Hàm này nằm ở internal/bootstrap/otel.go (anh thêm theo mẫu trước đó)
	tr := bootstrap.InitTracing(ctx, "wh-ma-api")
	defer func() { _ = tr.Shutdown(ctx) }()
```

==== Nhiệm vụ của Otel
```shell
Thu thập trace end-to-end cho mỗi HTTP request và xuất qua OTLP/HTTP tới otel-collector, từ đó đẩy sang Jaeger UI để tra cứu.
Đặt span cho request Gin (tên theo http.route) + gắn các thuộc tính cơ bản: method, path/route, status, error.
Sinh child spans cho Postgres (pgx) nên mỗi truy vấn DB nằm dưới cùng trace → thấy rõ đường đi request → DB.
Trả Trace-Id trong response header → tra cứu thẳng trên Jaeger.
Liên kết log ↔ trace: middleware log gắn trace_id/span_id vào bản ghi slog để soi log rồi nhảy qua trace dễ dàng.
