// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: plans.sql

package db

import (
	"context"
)

const getPlanForDevice = `-- name: GetPlanForDevice :one
SELECT device_id, threshold_min, threshold_max, created_at
FROM plans
WHERE device_id = $1
`

func (q *Queries) GetPlanForDevice(ctx context.Context, deviceID int64) (Plan, error) {
	row := q.db.QueryRow(ctx, getPlanForDevice, deviceID)
	var i Plan
	err := row.Scan(
		&i.DeviceID,
		&i.ThresholdMin,
		&i.ThresholdMax,
		&i.CreatedAt,
	)
	return i, err
}

const upsertPlan = `-- name: UpsertPlan :one
INSERT INTO plans (device_id, threshold_min, threshold_max, created_at)
VALUES ($1, $2, $3, COALESCE($4, NOW()))
ON CONFLICT (device_id) DO UPDATE
SET threshold_min = EXCLUDED.threshold_min,
    threshold_max = EXCLUDED.threshold_max
RETURNING device_id, threshold_min, threshold_max, created_at
`

type UpsertPlanParams struct {
	DeviceID     int64
	ThresholdMin float64
	ThresholdMax float64
	Column4      interface{}
}

func (q *Queries) UpsertPlan(ctx context.Context, arg UpsertPlanParams) (Plan, error) {
	row := q.db.QueryRow(ctx, upsertPlan,
		arg.DeviceID,
		arg.ThresholdMin,
		arg.ThresholdMax,
		arg.Column4,
	)
	var i Plan
	err := row.Scan(
		&i.DeviceID,
		&i.ThresholdMin,
		&i.ThresholdMax,
		&i.CreatedAt,
	)
	return i, err
}
