// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: alerts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkThresholdBreach = `-- name: CheckThresholdBreach :one
SELECT
  CASE
    WHEN lr.value < p.threshold_min THEN 'LOW'
    WHEN lr.value > p.threshold_max THEN 'HIGH'
    ELSE 'OK'
  END AS status,
  lr.id    AS reading_id,
  lr.value AS reading_value
FROM plans p
JOIN LATERAL (
  SELECT id, device_id, value, at
  FROM readings r
  WHERE r.device_id = p.device_id
  ORDER BY at DESC, id DESC
  LIMIT 1
) lr ON TRUE
WHERE p.device_id = $1
`

type CheckThresholdBreachRow struct {
	Status       string
	ReadingID    int64
	ReadingValue float64
}

func (q *Queries) CheckThresholdBreach(ctx context.Context, deviceID int64) (CheckThresholdBreachRow, error) {
	row := q.db.QueryRow(ctx, checkThresholdBreach, deviceID)
	var i CheckThresholdBreachRow
	err := row.Scan(&i.Status, &i.ReadingID, &i.ReadingValue)
	return i, err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO alerts (device_id, reading_id, level, message, is_serviced, created_at)
VALUES ($1, $2, $3, $4, FALSE, COALESCE($5, NOW()))
RETURNING id, device_id, reading_id, level, message, is_serviced, created_at, serviced_at
`

type CreateAlertParams struct {
	DeviceID  int64
	ReadingID pgtype.Int8
	Level     string
	Message   pgtype.Text
	Column5   interface{}
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.DeviceID,
		arg.ReadingID,
		arg.Level,
		arg.Message,
		arg.Column5,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.ReadingID,
		&i.Level,
		&i.Message,
		&i.IsServiced,
		&i.CreatedAt,
		&i.ServicedAt,
	)
	return i, err
}

const listOpenAlertsByDevice = `-- name: ListOpenAlertsByDevice :many
SELECT id, device_id, reading_id, level, message, is_serviced, created_at, serviced_at
FROM alerts
WHERE device_id = $1 AND is_serviced = FALSE
ORDER BY created_at DESC
`

func (q *Queries) ListOpenAlertsByDevice(ctx context.Context, deviceID int64) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listOpenAlertsByDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.ReadingID,
			&i.Level,
			&i.Message,
			&i.IsServiced,
			&i.CreatedAt,
			&i.ServicedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAlert = `-- name: ResolveAlert :one
UPDATE alerts
SET is_serviced = TRUE, serviced_at = COALESCE($2, NOW())
WHERE id = $1
RETURNING id, device_id, reading_id, level, message, is_serviced, created_at, serviced_at
`

type ResolveAlertParams struct {
	ID         int64
	ServicedAt pgtype.Timestamptz
}

func (q *Queries) ResolveAlert(ctx context.Context, arg ResolveAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, resolveAlert, arg.ID, arg.ServicedAt)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.ReadingID,
		&i.Level,
		&i.Message,
		&i.IsServiced,
		&i.CreatedAt,
		&i.ServicedAt,
	)
	return i, err
}
